# LABORATORIO 09
## Listas estáticas, Matrices y Tipos mixtos
### TAREA 1. Ejercicios obligatorios
1. **Insertar en medio.** Implementa el _procedimiento_ **Insertar_En_Medio** que, a partir de una lista estática y un número natural N, lo inserte en la mitad de la lista, si el número de elementos de la lista es par. Si el número de elementos de la lista es impar o la lista está llena se deja la lista como está. Por ejemplo, si L= [4, 5, 3, 6] y N= 9 debería quedar [4, 5, 9, 3, 6]. Si L= [4, 6, 3] y N= 9 debería quedar [4, 6, 3]. Si L= [] y N= 3 debería quedar [3].
2. **Borrar intermedio.** Implementa el _procedimiento_ **Borrar_Intermedio** que, dada una lista estática de enteros L, la modifique eliminando el elemento intermedio (aquel que tiene el mismo número de nodos antes y después de dicho elemento). Esto significa que el subprograma debe eliminar un elemento SOLO cuando L tiene un número impar de elementos. Si L tiene un número par de elementos, entonces no se hace nada a la lista de partida.
3. **Encriptar.** Implementa el _procedimiento_ **Encriptar** que, dados dos vectores de enteros N, Clave, devuelva otro vector Num con los dígitos de N recolocados usando la clave. N representa los dígitos de un número entero y clave tiene los números de 1 a N’length. Para encriptar N, se coloca cada uno de los dígitos de N en la posición indicada en V_Clave, suponiendo siempre que el número N se rellena con tantos ceros a la izquierda como sea necesario. Por ejemplo, si N es (8,7,5,3,9) y Clave es (2,4,1,5,3), el resultado es (5,8,9,7,3), ya que el 8 va a la segunda posición, el 7 va a la cuarta posición, el 5 va a la primera posición, el 3 va a la quinta posición y el 9 va a la tercera posición. Si N es(5,7,6) y Clave es (2,4,1,5,3), el resultado es (5,0,6,0,7) ya que el (5,7,6) se considera como si tuviera cinco cifras (0,0,5,7,6) y luego se aplica el algoritmo de encriptación: el primer 0 va a la segunda posición, el segundo 0 va a la cuarta posición, el 5 va a la primera posición, el 7 va a la quinta posición y el 6 va a la tercera posición.
4. **Intersección.** Implementa la _función_ **comunes** que, dados dos vectores de enteros cuyos valores están ordenados crecientemente, devuelva cuántos elementos son comunes a los dos vectores. Como ejemplo, con (3, 4, 5, 6, 7, 8, 9, 10, 11, 12) y (9, 11, 13, 15, 17, 19, 21, 23, 25, 27), devuelve 2 (el 9 y el 11 son comunes a los dos). Nota: El hecho de que los vectores estén ordenados debe influir en el algoritmo a utilizar y una solución con dos bucles anidados no es aceptable.
5. **Calcular el número de vecinos por vivienda del edificio.** Implementa en Ada el _procedimiento_ **Obtener_Num_Vecinos_Por_Vivienda** que, dados los datos de toda la comunidad, obtenga la distribución de los vecinos por vivienda en el rascacielos. Tenemos datos de los 3.546 vecinos de una comunidad de vecinos. Por cada vecino tenemos información de su nombre, número de piso y mano donde vive. La comunidad vive en un rascacielos de 100 pisos (numerados del 1 al 100) y en cada piso hay 10 manos (nombradas desde la ‘A’ a la ‘J’). Para acceder más fácilmente al número de habitantes por cada vivienda (piso y mano concretos), queremos transformar los datos en otra estructura de datos (matriz T_Rascacielos). Por ejemplo, si en el 1º A viven 5 personas en el vector de la comunidad habrá 5 posiciones en las que aparecerá información de vecinos del piso 1 y mano A. Tras el proceso de ir revisando el vector de la comunidad de vecinos, en R (de Programación básica 53 Lab09 tipo T_Rascacielos) aparecerá el valor 5 en la primera celda, es decir, R(1, A)=5. NOTA sobre eficiencia: el procedimiento debe resolver el problema con un único recorrido del vector de la Comunidad.

    <div align="center">
        <img src="https://github.com/lukabergs/ia-pb-lab09/assets/52601751/1d9c445c-ed47-4696-9448-8ef699ac2411" title="Fig. 1">
    </div>

6. **Obtener información de consumos.** Tenemos información de una comunidad de vecinos que vive distribuida en un rascacielos de 100 pisos (numerados del 1 al 100) y por cada piso hay 10 manos (nombradas de la 'A' a la 'J'). Por cada vivienda (piso y mano concretos) tenemos información del consumo de electricidad, consumo de gas y número de habitantes. Toda esa información la representamos con T_Edificio. Implementa el _procedimiento_ **Obtener_Consumos** que, dada la información de todo el edificio, y _**utilizando un único recorrido de la matriz**_, obtenga, teniendo en cuenta el número de habitantes en cada piso: (1) el consumo eléctrico medio por habitante de todo el rascacielos (un único valor para todo el edificio, el cálculo usa todos los habitantes del edificio), y (2) los consumos medios de gas por habitante de cada mano del rascacielos (10 valores distintos, uno para cada mano; usa T_Consumo_Medio_Manos para el resultado; en cada cálculo solo se tienen en cuenta los habitantes de esa mano en el edificio).
### TAREA 2. Ejercicios extra
7. **Lluvias.** Implementa el _procedimiento_ **Maximo** que, dados los datos pluviométricos del siglo XXI, y dos fechas de este siglo, indique cuál es el mes que más ha llovido de los que se encuentran incluidos entre esas dos fechas. En los extremos solo se cuentan los días del mes que se incluyen. Por ejemplo, Entre el 10-ENE-2011 y el 15-Ene-2011 el resultado debe ser ENERO-2001, porque solo está ese mes comprendido entre esas dos fechas. Si fuera entre 10-ENE-2011 y 15-FEB-2011, entonces se contarían las lluvias entre el 10 y el 31 de enero frente a las del 1 al 15 de febrero. En la fecha de resultado, el valor del día no tiene relevancia (solo importan los otros dos).
8. **Simplificar lista de carreteras 1.** Implementa el _procedimiento_ **Simplificar** que, a partir de una lista estática de carreteras L de tipo T_Estatica_Carreteras, elimine de ella las cinco primeras que sean de peaje y las devuelva en una lista nueva en el mismo orden en que se encuentran. Se considera que una carretera es de peaje cuando tiene más de 0 km de peaje. Nota: Se penalizará el uso de listas auxiliares en la resolución del problema.
9. **Simplificar lista de carreteras 2.** Tenemos una representación de carreteras con demasiados puntos y queremos reducir el espacio de memoria necesario para representarlas aun perdiendo algo de información. Implementa en Ada el _procedimiento_ **Simplificar** que, a partir de una _**lista**_ de carreteras L de tipo T_Estatica_Carreteras, _**la modifique**_ eliminando para cada carretera aquellos puntos cuyas diferencias en los valores X e Y con el punto anterior sean menores que 0.001 (en ambos valores). Los puntos que se queden en la lista deben mantener el orden de la lista original y los puntos inicial y final siempre se habrán de mantener. _**Nota:**_ Se penalizará el uso de listas auxiliares en la resolución del problema.
10. **Simplificar lista de puntos.** Implementa en Ada el _procedimiento_ Simplificar que, a partir de una _**lista**_ de puntos no vacía L de tipo T_Estatica_Puntos, _**la modifique**_ para que solo contenga un cuarto de los puntos, respetando uno sí y tres no de la lista original. Los puntos que se queden en la lista deben mantener el orden de la lista original y los puntos inicial y final siempre se habrán de mantener. También se devolverá el número de puntos restantes en la lista resultado. Nota: Se penalizará el uso de listas auxiliares. Para reducir la lista se añade al final un punto de coordenadas (-1,-1), A partir de ahí, los puntos se ignoran. Por ejemplo:
    - Si L= <p1, p2> el resultado sería <p1, p2> y **2**.
    - Si L= <p1, p2, p3, p4> el resultado sería <p1, p4> y **2**.
    - Si L= <p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11> el resultado sería <p1, p5, p9, p11> y **4**.
11. **Localizar máximo patrimonio.** Implementa la _función_ **dni_mayor_patrimonio** que, dada una urbanización U, devuelve el DNI de la persona de la urbanización que tiene un mayor patrimonio. Se considera que el patrimonio es la suma de los valores de los pisos que posee. Para resolver este ejercicio necesitarás guardar el patrimonio de cada uno de los diferentes propietarios que te vayas encontrando e ir actualizando su patrimonio. Se sugiere que definas una lista estática en la que guardar por cada elemento dos datos: el dni de un propietario y su patrimonio detectado. Para resolver el problema se tendrá que recorrer todas las propiedades de la urbanización. Para cada propiedad, si el propietario ya estaba registrado previamente, se actualiza su patrimonio con el valor de la propiedad actual y, si no, se añade a la lista con el valor de la propiedad actual como patrimonio. Finalmente, se recorre esta estructura auxiliar para localizar el propietario con mayor patrimonio.
### TAREA 3. Ejercicios para pensar – Otros tipos de registro
12. **Localizar espacio en blanco de sudoku.** En un sudoku siempre hay 9 fichas, cada una con los 9 números (1, 2, …9). En este ejercicio se tiene una matriz NxN (9x9) para representar un sudoku a medio rellenar. En una ficha sin rellenar, en blanco, los números en blanco se representan con el valor 0. Aparte, se dispone de una ficha, representada por una matriz cuadrada MxM (3x3), que hay que colocar en el sudoku. Por ejemplo: Se dispone del siguiente sudoku, que tiene hueco para una ficha, y una ficha a colocar:

    <div align="center">
        <img src="https://github.com/lukabergs/ia-pb-lab09/assets/52601751/d4cb3c68-142d-4ae3-bbac-d8d8a95ab6c0" title="Fig. 2">
    </div>

    Una ficha no encaja en el sudoku si algún número se repite en alguna columna, fila, o en la misma ficha. Por ejemplo, tal y como está la ficha, no encaja en el hueco del sudoku, pero también se quiere examinar si puede ser colocada girada 90, 180 o 270 grados:

    <div align="center">
        <img src="https://github.com/lukabergs/ia-pb-lab09/assets/52601751/dece5395-9320-4dbb-888c-82d96ba10f09" title="Fig. 3">
    </div>

    En la fila 7, se repiten los números 8 y 3. En la fila 8 se repiten los números 7 y 9. En la fila 9, se repiten los números 2 y 5. En la columna 7, se repiten los números 6 y 9. En la columna 8 se repiten los números 3 y 5. En la columna 9, se repiten los números 1 y 7. La ficha, tal y como está, no se puede colocar en el hueco blanco del sudoku. Pero, la ficha se puede rotar hacia la derecha para poder encontrar su colocación. Por ejemplo, si se rota la ficha hacia la derecha, se obtienen las siguientes fichas:

    <div align="center">
        <img src="https://github.com/lukabergs/ia-pb-lab09/assets/52601751/cb99894f-8867-4790-8678-1306298f44a3" title="Fig. 4">
    </div>

    Si se rota la ficha 270º, entonces sí que encaja en el sudoku, ya que los números no se repiten en ninguna fila ni columna:

    <div align="center">
        <img src="https://github.com/lukabergs/ia-pb-lab09/assets/52601751/3524fdd4-a2bb-4ed7-9f1c-86ae37639a4e" title="Fig. 5">
    </div>

    Implementa el _procedimiento_ **encontrar_espacio_blanco**. Un espacio en blanco es una submatriz MxM con todas las casillas con el valor 0. Se supone que si un número tiene el valor 0, el resto de los números de esa ficha también lo son.
  
12. **Rotar matriz derecha de sudoku.** Implementa el _procedimiento_ **rotar_matriz_derecha_90**, que, dada una ficha, la rote 90º a la derecha. Nota: Se busca una solución transportable a fichas de cualquier tamaño, por lo que se penalizarán soluciones que no incluyan un bucle.

13. **Comprobar filas correctas de sudoku.** Implementa la _función_ **filas_correctas**, que, dados un sudoku sin terminar (con un espacio para una ficha), una ficha, y la especificación de la casilla superior izquierda de un hueco del sudoku, compruebe que si el resultado de añadir la ficha a el sudoku con un espacio en blanco, todas las filas y las columnas cumplen los requisitos.
